[{"content":"线性表 目标： 1. 线性结构特点\r2. 顺序表的定义，创建，插入，删除\r3. 链表的定义，创建，插入，删除\r4. 场景分析\r特点 用数据元素的有限序列表示 同一线性表中的元素必定具有相同的特性\n顺序表 顺序表又称 顺序存储结构/顺序映像\n定义: 逻辑上相邻，物理上也相邻\n存储方法: 用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现。\n顺序表的类型定义 示例：\n顺序表的基本算法操作 初始化 1 2 3 4 5 6 Status InitList_Sq(SqList \u0026amp;L){ //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0;\t//空表长度为0 return OK; } //参数使用引用 1 2 3 4 5 6 Status InitList_Sq(SqList *L){ //构造一个空的顺序表L L-\u0026gt; elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(! L-\u0026gt; elem) exit(OVERFLOW); //存储分配失败 L-\u0026gt; length=0;\t//空表长度为0 return OK; } //参数使用指针 取值（根据位置i获取对应位置的数据元素） 1 2 3 4 5 6 7 int GetElem(SqList L,int i,ElemType \u0026amp;e) { if (i\u0026lt;1||i\u0026gt;L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e=L.elem[i-1]; //第i-1的单元存储着第i个数据 return OK; } 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 int LocateELem(SqList L,ElemType e) { for (i=0;i\u0026lt; L.length;i++) if (L.elem[i]==e) return i+1; return 0; } 插入（插在第 i 个结点之前） （1）判断插入位置i 是否合法。\n（2）判断顺序表的存储空间是否已满。\n（3）将第n至第i 位的元素依次向后移动一个位置，空出第i个位置。\n（4）将要插入的新元素e放入第i个位置。\n（5）表长加1，插入成功返回OK。\n1 2 3 4 5 6 7 8 9 Status ListInsert_Sq(SqList \u0026amp;L,int i ,ElemType e){ if(i\u0026lt;1 || i\u0026gt;L.length+1) return ERROR;\t//i值不合法 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(j=L.length-1;j\u0026gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length;\t//表长增1 return OK; } 删除（删除第i个节点） （1）判断删除位置i 是否合法（合法值为1≤i≤n）。\n（2）将欲删除的元素保留在e中。\n（3）将第i+1至第n 位的元素依次向前移动一个位置。\n（4）表长减1，删除成功返回OK。\n1 2 3 4 5 6 7 Status ListDelete_Sq(SqList \u0026amp;L,int i){ if((i\u0026lt;1)||(i\u0026gt;L.length)) return ERROR;\t//i值不合法 for (j=i;j\u0026lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; } 顺序表的特点 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致\n在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等　这种存取方法称为随机存取法\n优点：\n存储密度大（结点本身所占存储量/结点结构所占存储量）\n可以随机存取表中任一元素\n缺点：\n在插入、删除某一元素时，需要移动大量元素\n浪费存储空间\n属于静态存储形式，数据元素的个数不能自由扩充\n顺序表的时间，空间复杂度 查找、插入、删除算法的平均时间复杂度为 O(n)\n顺序表的空间复杂度S(n)=O(1) （没有占用辅助空间）\n链表 结点在存储器中的位置是任意的即逻辑上相邻的数据元素在物理上不一定相邻\n通过指针进行实现\n各结点由两个域组成：\n数据域：存储元素数值数据\n指针域：存储直接后继结点的存储位置\n链表的分类：单链表，双链表，循环链表\n单链表：结点只有一个指针域。\n双链表：结点有两个指针域的链表\n循环链表：首尾相接的链表\n头指针，头结点和首元结点 链表表头设置头结点的好处：\n方便首元结点处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;\n便于空表和非空表的统一处理 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\nPS：头结点可以为空，也可以存储线性表长度的附加信息，不会被记录长度\n单链表的定义与实现 单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名\n若头指针名是L，则把链表称为表L\nLNode * 与 LinkList 等价\n单链表的基本算法操作 初始化 1 2 3 4 5 Status InitList_L(LinkList \u0026amp;L){ L=new LNode; L-\u0026gt;next=NULL;　return OK; } 销毁 1 2 3 4 5 6 7 8 9 10 Status DestroyList_L(LinkList \u0026amp;L){ LinkList p; while(L) { p=L; L=L-\u0026gt;next; delete p; } return OK; } 清空 1 2 3 4 5 6 7 8 9 Status ClearList(LinkList \u0026amp; L){ // 将L重置为空表 LinkList p,q; p=L-\u0026gt;next; //p指向第一个结点 while(p) //没到表尾 { q=p-\u0026gt;next; delete p; p=q; } L-\u0026gt;next=NULL; //头结点指针域为空 return OK; } 求表长 1 2 3 4 5 6 7 8 9 10 int ListLength_L(LinkList L){ //返回L中数据元素个数 LinkList p; p=L-\u0026gt;next; //p指向第一个结点 i=0; while(p){//遍历单链表,统计结点数 i++; p=p-\u0026gt;next; } return i; } 判断表是否为空 1 2 3 4 5 6 7 int ListEmpty(LinkList L){ //若L为空表，则返回1，否则返回0 if(L-\u0026gt;next) //非空 return 0; else return 1; } 取值（根据位置i获取相应位置数据元素的内容） 1 2 3 4 5 6 7 8 9 Status GetElem_L(LinkList L,int i,ElemType \u0026amp;e){ p=L-\u0026gt;next;j=1; //初始化 while(p\u0026amp;\u0026amp;j\u0026lt;i){\t//向后扫描，直到p指向第i个元素或p为空 p=p-\u0026gt;next; ++j; } if(!p || j\u0026gt;i)return ERROR; //第i个元素不存在 e=p-\u0026gt;data; //取第i个元素 return OK; }//GetElem_L 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 LNode *LocateELem_L (LinkList L，Elemtype e) { //返回L中值为e的数据元素的地址，查找失败返回NULL p=L-\u0026gt;next; while(p \u0026amp;\u0026amp;p-\u0026gt;data!=e) p=p-\u0026gt;next; return p; } 插入（插在第 i 个结点之前） 1 2 3 4 5 6 7 8 9 10 Status ListInsert_L(LinkList \u0026amp;L,int i,ElemType e){ p=L;j=0; while(p\u0026amp;\u0026amp;j\u0026lt;i−1){p=p-\u0026gt;next;++j;}\t//寻找第i−1个结点 if(!p||j\u0026gt;i−1)return ERROR;\t//i大于表长 + 1或者小于1 s=new LNode;\t//生成新结点s s-\u0026gt;data=e; //将结点s的数据域置为e s-\u0026gt;next=p-\u0026gt;next;\t//将结点s插入L中 p-\u0026gt;next=s; return OK; }//ListInsert_L 删除（删除第 i 个结点） 1 2 3 4 5 6 7 8 9 10 11 12 Status ListDelete_L(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ p=L;j=0; while(p-\u0026gt;next \u0026amp;\u0026amp;j\u0026lt;i-1){//寻找第i个结点，并令p指向其前驱 p=p-\u0026gt;next; ++j; } if(!(p-\u0026gt;next)||j\u0026gt;i-1) return ERROR; //删除位置不合理 q=p-\u0026gt;next; //临时保存被删结点的地址以备释放 p-\u0026gt;next=q-\u0026gt;next; //改变删除结点前驱结点的指针域 e=q-\u0026gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; }//ListDelete_L 链表的特点 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等\n这种存取元素的方法被称为顺序存取法\n优点:\n数据元素的个数可以自由扩充\n插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高\n缺点：\n存储密度小\n存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）\n链表的时间，空间复杂度 查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。\n插入和删除: 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为 O(1)。\n如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 。\n*单链表的建立 方法一：前插法\n1 2 3 4 5 6 7 8 9 10 void CreateList_F(LinkList \u0026amp;L,int n){ L=new LNode; L-\u0026gt;next=NULL; //先建立一个带头结点的单链表 for(i=n;i\u0026gt;0;--i){ p=new LNode; //生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; //插入到表头 } }//CreateList_F 方法二：后插法\n1 2 3 4 5 6 7 8 9 10 11 12 void CreateList_L(LinkList \u0026amp;L,int n){ //正位序输入n个元素的值，建立带表头结点的单链表L L=new LNode; L-\u0026gt;next=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u0026lt;n;++i){ p=new LNode;\t//生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=NULL; r-\u0026gt;next=p; //插入到表尾 r=p; //r指向新的尾结点 } }//CreateList_L *双向链表和循环链表的共性特点 循环链表和双向链表是两种常见的链式存储结构，它们的共性如下：\n都是链式存储：链式存储是指线性数据结构的一种存储方式，在这种方式中，数据不是顺次存储在内存单元中，而是通过一个指针将相邻的数据连接在一起。\n都可以实现动态的数据存储：链式存储的线性结构可以随着数据的添加和删除动态变化，避免因为数据量固定导致的内存浪费。\n都是非连续存储：链式存储的数据不是顺次存储在内存单元中，而是分散存储在各个不同的内存单元中，因此是非连续的。\n循环链表的特点：\n循环：循环链表是一种特殊的链式存储结构，其特殊之处在于，最后一个数据元素的指针指向链表的第一个元素，实现了循环结构。\n方便遍历：由于循环链表结构中的数据元素是相互连接的，因此，可以方便地从一个数据元素遍历到另一个数据元素。\n双向链表的特点：\n双向链接双向链表是一种特殊的链式存储结构，每个数据元素同时包含了前驱和后继的指针，使得可以从前面和后面同时遍历链表。\n方便插入和删除：由于双向链表中每个数据元素都包含了前驱和后继的指针，因此，可以方便地在链表的任意位置插入和删除数据元素。\n顺序表和链表的比较 ","date":"2023-02-12T00:00:00Z","image":"https://sryasuka.fun/p/linear-tables/168b829abbf5013cf165952489969f2_hua6ee4ed3cf660c859c134ad90be5e6ce_35023_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/linear-tables/","title":"线性表"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://sryasuka.fun/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://sryasuka.fun/p/test-chinese/","title":"Chinese Test"}]