[{"content":"流和文件描述符及之间的关系 在计算机操作系统中，流和文件描述符是紧密相关的概念，它们之间的关系如下：\n文件描述符：文件描述符是一个非负整数，用于标识打开文件或其他输入/输出设备的唯一标识符。在Unix和类Unix系统中，每个打开的文件或设备都被分配一个文件描述符，它是操作系统内部使用的一个数字，程序可以通过文件描述符来访问文件或设备。\n流：流是一个抽象的概念，它表示从程序中一个地方到另一个地方的数据流动。流可以是输入流、输出流或输入/输出流，它们在程序中通过流对象来实现。流对象封装了文件描述符及其相关操作，使得程序可以以更高级别的方式进行输入和输出操作，而不需要直接操作文件描述符。\n流和文件描述符的关系：在Unix和类Unix系统中，每个流都与一个文件描述符相关联。例如，标准输入流stdin通常与文件描述符0相关联，标准输出流stdout通常与文件描述符1相关联，标准错误流stderr通常与文件描述符2相关联。在程序中使用流对象来进行输入/输出操作时，操作系统会自动将流对象转换为与其相关联的文件描述符来进行底层的读写操作。\n三个标准流 三个标准流通常指的是：标准输入流（stdin）、标准输出流（stdout）和标准错误流（stderr），在计算机操作系统中被广泛使用。\n标准输入流（stdin）：这是程序从用户那里获取输入数据的标准方式。标准输入流通常通过键盘输入，但也可以通过文件、管道或其他设备输入。在Linux和Unix操作系统中，可以使用重定向符号 \u0026ldquo;\u0026lt;\u0026rdquo; 来将一个文件中的内容输入到标准输入流中。\n标准输出流（stdout）：这是程序输出数据的标准方式。标准输出流通常是显示在屏幕上的文本信息，但也可以重定向到文件中。在Linux和Unix操作系统中，可以使用重定向符号 \u0026ldquo;\u0026gt;\u0026rdquo; 来将标准输出流的内容写入一个文件中。\n标准错误流（stderr）：这是程序输出错误信息的标准方式。标准错误流通常是显示在屏幕上的红色文本信息，以便用户注意到它们。与标准输出流不同，标准错误流的输出不会被重定向到文件中，除非专门使用特定的符号 \u0026ldquo;2\u0026gt;\u0026rdquo; 进行重定向。\n打开和关闭流 流缓冲区和内核缓冲区 流缓冲区：流缓冲区是在程序内部使用的一个缓冲区，它存储了要写入或读取的数据。当程序进行输出操作时，数据首先被写入到流缓冲区中，直到缓冲区满或程序调用了flush()函数或关闭流时才将数据写入到内核缓冲区中。当程序进行输入操作时，数据也是首先从内核缓冲区读取到流缓冲区中，直到缓冲区为空或程序读取了足够的数据时才会再次从内核缓冲区中读取数据。\n内核缓冲区：内核缓冲区是操作系统内核使用的一个缓冲区，它用于存储要写入或读取的数据。当程序进行输出操作时，数据从流缓冲区写入到内核缓冲区中，然后由内核将数据写入到磁盘或网络中。当程序进行输入操作时，数据首先从磁盘或网络中读取到内核缓冲区中，然后由内核将数据从内核缓冲区中复制到流缓冲区中，供程序读取。\n总体上，流缓冲区是程序内部使用的缓冲区，它可以提高输入/输出操作的效率。内核缓冲区是操作系统内核使用的缓冲区，它可以提高磁盘和网络读写的效率。流缓冲区和内核缓冲区的关系是：程序将数据写入到流缓冲区中，然后由内核将数据从流缓冲区复制到内核缓冲区中；或者程序从内核缓冲区中读取数据，然后将数据存储到流缓冲区中。\n流缓冲区类型 文件描述符表、打开文件表和i-node表 在 Unix/Linux 系统中，文件是使用文件描述符（file descriptor）来进行操作的。文件描述符是一个整数，它代表一个文件被打开后在内核中的一个唯一标识符。当应用程序打开一个文件时，内核会分配一个文件描述符，并使用该文件描述符来标识该文件。文件描述符表、打开文件表和 i-node 表是三个与文件操作密切相关的概念，它们分别记录了文件描述符、打开文件和文件在磁盘上的存储位置。\n文件描述符表：文件描述符表是每个进程都有的一个表，它记录了进程中每个打开的文件描述符与内核中的文件描述符之间的映射关系。当应用程序打开一个文件时，内核会分配一个文件描述符，并将其添加到文件描述符表中，以便应用程序在之后的操作中可以使用该文件描述符来标识该文件。\n打开文件表：打开文件表是内核中的一个表，它记录了所有当前被打开的文件的信息，包括文件描述符、文件偏移量、读写模式、文件状态等等。当应用程序打开一个文件时，内核会在打开文件表中创建一个新的表项，并将该表项与文件描述符关联起来。\ni-node 表：i-node 表是在磁盘上维护的一个表，它记录了文件的所有属性和存储位置。每个文件在 i-node 表中都有一个唯一的 i-node 号码，该号码与文件的所有属性和存储位置相关联。当应用程序打开一个文件时，内核会通过文件的 i-node 号码在 i-node 表中查找该文件的相关信息，包括文件类型、访问权限、文件大小、创建时间等等。\n这三个表之间的关系是：文件描述符表中的文件描述符指向打开文件表中的打开文件，而打开文件表中的打开文件又与 i-node 表中的文件相关联。在进行文件操作时，应用程序使用文件描述符来标识文件，内核根据文件描述符在打开文件表中查找相应的打开文件，然后根据打开文件中的 i-node 号码在 i-node 表中查找文件的相关信息。\n","date":"2023-02-20T00:00:00Z","image":"https://sryasuka.fun/p/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Linux_ch02_hu3f69bb3da5628383156e983128f03802_76860_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"标准输入输出"},{"content":"UNIX标准及两级规范符号度 UNIX是一个操作系统的家族，它的标准是由The Open Group制定的。该标准包括了Single UNIX Specification和POSIX标准两个级别。\nSingle UNIX Specification（SUS）是一份针对UNIX系统的单一规范，它包括了许多开放标准和互操作性标准，用于确保UNIX系统在不同的平台上保持一致的行为。SUS包括了许多子规范，包括基本系统接口、命令和工具、系统管理、应用程序接口等。\nPOSIX标准定义了UNIX系统应该提供的一组接口，这些接口主要用于实现可移植的UNIX应用程序。POSIX标准涵盖了操作系统、编程语言和工具等方面，包括了许多子规范，如POSIX.1，POSIX.2等。\nGPL/LGPL GPL软件允许商业销售，但不允许闭源。它确保了程序代码永远能让所有人自由使用。\nLGPL软件/库允许商业销售，但不允许闭源；但动态链接LGPL库时，允许软件闭源。它主要为库的使用而设计的许可。\nUNIX哲学 小即是美 让每一个程序只做好一件事 尽快建立原型 舍高效率而取可移植性 \u0026ndash;代码可移植 采用纯文本文件存储数据 \u0026ndash;数据可移植 充分利用软件的杠杆效应 使用shell脚本来提高杠杆效应和可移植性 避免强制性的用户界面 灵活性：编程时应尽量考虑到灵活性，尽量避免随意限制字段长度或记录数目。 可重用组件：将应用程序的核心实现为库。 Linux标准 Linux标准是由Linux Standard Base（LSB）组织定义和维护的，它是一个用于确保不同Linux发行版之间二进制兼容性的标准。\nLSB规范定义了一组Linux系统所必须支持的接口、库和命令等，这些接口和命令可用于开发和运行Linux应用程序，从而提高应用程序的可移植性和互操作性。\n内核态和用户态 现代处理器架构一般允许CPU至少在两种不同状态下运行，即内核态和用户态。执行硬件指令可使CPU在两种状态间来回切换。\n进程所能访问的存储位置范围称为虚拟地址空间。与之对应，虚拟内存空间也分为内核空间和用户空间。进程在用户态下运行时，CPU只能访问用户空间，试图访问内核空间的内存将会引起硬件异常。当运行于内核态时，CPU既能访问用户空间内存，也能访问内核空间内存。\nshell提示符结构 常见的 shell有：\nBash(the GNU Bourne-Again Shell)、TC shell、Z shell； //Linux\nBourne shell、Korn shell、C shell //UNIX\n常见的Shell提示符结构包括以下几个组成部分：\n用户名：表示当前登录系统的用户名，可以使用环境变量$USER或$(whoami)来获取。\n主机名：表示当前计算机的主机名或IP地址，可以使用环境变量$HOSTNAME或$(hostname)来获取。\n当前工作目录：表示当前所在的工作目录，可以使用环境变量$PWD来获取。\nShell类型或版本号：表示当前Shell的类型或版本号，可以使用环境变量$SHELL或$BASH_VERSION来获取。\n提示符符号：表示提示符的结束符号，一般为$或#，其中$表示普通用户，#表示超级用户（即root用户）。\nLinux重定向命令 输出重定向（\u0026gt;）：将命令执行的结果输出到一个文件中，可以使用大于符号（\u0026gt;）进行重定向。\n输出追加重定向（\u0026raquo;）：与输出重定向类似，但是将命令执行的结果追加到文件的末尾而不是覆盖原有内容。\n输入重定向（\u0026lt;）：将一个文件中的内容作为命令的输入数据，可以使用小于符号（\u0026lt;）进行重定向。\n文件描述符重定向（\u0026amp;\u0026gt;）：将命令执行的结果同时重定向到标准输出和标准错误输出文件中。\n后台运行命令 在Linux或Unix系统中，可以通过在命令末尾加上\u0026amp;符号，将命令放入后台运行。这种方式可以使得命令在后台执行，而不会占用终端或命令行界面的资源，同时也可以在命令执行过程中继续使用终端或命令行界面进行其他操作。\n后台运行普通命令：在普通命令末尾加上\u0026amp;符号即可将命令放入后台运行 sleep 10 \u0026amp;\n后台运行交互式命令：对于交互式命令，如果直接加上\u0026amp;符号，命令仍然会在前台运行。可以使用nohup命令将交互式命令转为后台运行模式 nohup python3 -i\n挂起已经在前台运行的命令：如果已经在前台运行的命令需要挂起，可以使用Ctrl + Z快捷键将其暂停，并放入后台运行。 1 2 3 tar czf backup.tar.gz /path/to/backup \u0026amp; [1] 12345 $ fg 系统调用和库函数间关系 操作系统具有两种功能：为用户程序提供抽象和管理计算机资源。通常程序和OS之间处理的是前者，例如，创建、写入、读出和删除文件。对用户而言，资源管理部分主要是透明和自动完成的。\n系统调用就是OS的一些内建函数，这些函数为应用程序提供了对计算机资源的抽象，使程序同硬件特性相隔离。从编程的角度看，系统调用的集合及系统调用的内部实现形成了OS的内核。\nC使用_syscall宏，可以直接调用任何系统调用。然而，为了调用方便，标准C库提供了一组针对最常用系统调用的封装(wrapper)函数。封装函数与系统调用通常同名，它将系统调用参数打好包，通过适当的方式陷入内核执行，然后将返回状态传递给应用程序。\n内核是为用户进程运行的，它不是与用户进程平行运行的独立的进程集合，而是每个用户进程的一部分。 用户进程的代码由用户代码(应用程序代码+库)和内核代码组成，执行时常常在用户态和内核态之间切换。\n系统调用通常需要通过内核态和用户态之间的上下文切换来完成，因此效率相对较低，但提供了更底层、更强大的功能。开销大\n库函数通常是在用户态中执行的，因此效率相对较高，但功能相对较弱。开销小。\n在需要对系统进行精确控制时，最好使用系统调用，这可以避免使用库函数带来的一些想不到的问题。\n保留字： 保留字是系统专门保留使用权，并有特定含义的名字，具有唯一性。\n常见的一级目录 链接和库 可执行程序的生成需要经历预处理、编译、汇编、链接4个阶段。\n默认情况下，链接器只搜索默认lib目录(/lib和/usr/lib)中的C标准库libc.a或者libc.so；其余的库(如数学库libm.a或libm.so)则需要指定库的名字甚至库的路径信息才能被链接器搜索到。\n链接的时机： 编译时，即源代码被翻译成机器代码时 (ld) 加载时，即在程序被加载器加载到存储器并准备执行时(ld-linux.so) 运行时，即程序正在运行时(libdl.so.2)\n","date":"2023-02-18T00:00:00Z","image":"https://sryasuka.fun/p/linuxgplunix%E4%BB%8B%E7%BB%8D/Linux_ch01_hua27b2c25dc2bad5a4da2101f5d236246_119733_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/linuxgplunix%E4%BB%8B%E7%BB%8D/","title":"Linux，GPL，UNIX介绍"},{"content":"栈和队列 目标：\r1. 掌握栈和队列的特点，并能在相应的应用问题中正确选用\r2. 熟练掌握栈的两种存储结构的基本操作实现算法，特别应注意栈满和栈空的条件\r3. 熟练掌握循环队列和链队列的基本操作实现算法，特别注意队满和队空的条件\r4. 理解递归算法执行过程中栈的状态变化过程\r5. 掌握表达式求值 方法\r栈的定义 定义：只能在表的一端（栈顶）进行插入和删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见\n运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则\n实现方法：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同。基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等\n队列的定义 定义：只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序队列或链队存储均可\n运算规则：先进先出（FIFO）\n实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同\n*栈，队列和一般线性表的区别 栈、队列是一种特殊（操作受限）的线性表\n区别：仅在于运算规则不同\n一般线性表：\n逻辑结构：一对一 存储结构：顺序表、链表 运算规则：随机、顺序存取 栈\n逻辑结构：一对一 存储结构：顺序栈、链栈 运算规则：后进先出 队列\n逻辑结构：一对一 存储结构：顺序队、链队 运算规则：先进先出 栈的表示和操作的实现 进栈 = 压入 = PUSH()\n出栈 = 弹出 = POP()\n顺序栈与顺序表的区别\n顺序栈的表示 1 2 3 4 5 6 #define MAXSIZE 100 typedef struct{ SElemType *base; SElemType *top; int stacksize; }SqStack; 顺序栈初始化 1 2 3 4 5 6 7 8 9 Status InitStack( SqStack \u0026amp;S ) { S.base =new SElemType[MAXSIZE]； if( !S.base ) return OVERFLOW; S.top = S.base; S.stackSize = MAXSIZE; return OK; } 判断顺序栈是否为空 1 2 3 4 5 6 7 bool StackEmpty( SqStack S ) { if(S.top == S.base) return true; else return false; } 清空顺序栈 1 2 3 4 5 Status ClearStack( SqStack S ) { if( S.base ) S.top = S.base; return OK; } 销毁顺序栈 1 2 3 4 5 6 7 8 9 10 Status DestroyStack( SqStack \u0026amp;S ) { if( S.base ) { delete S.base ; S.stacksize = 0; S.base = S.top = NULL; } return OK; } 顺序栈进栈 1 2 3 4 5 6 7 Status Push( SqStack \u0026amp;S, SElemType e) { if( S.top - S.base== S.stacksize ) // 栈满 return ERROR; *S.top++=e; // *S.top = e; S.top++; return OK; } 顺序栈出栈 1 2 3 4 5 6 7 Status Pop( SqStack \u0026amp;S, SElemType \u0026amp;e) { if( S.top == S.base ) // 栈空 return ERROR; e＝ *--S.top; // --S.top; e = *S.top; return OK; } 链栈的表示 1 2 3 4 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; 初始化 1 2 3 4 void InitStack(LinkStack \u0026amp;S ) { S=NULL; } 判断链栈是否为空 1 2 3 4 5 Status StackEmpty(LinkStack S) { if (S==NULL) return TRUE; else return FALSE; } 链栈进栈 1 2 3 4 5 6 7 Status Push(LinkStack \u0026amp;S , SElemType e) { p=new StackNode; //生成新结点p if (!p) exit(OVERFLOW); p-\u0026gt;data=e; p-\u0026gt;next=S; S=p; return OK; } 链栈出栈 1 2 3 4 5 6 7 Status Pop (LinkStack \u0026amp;S,SElemType \u0026amp;e) { if (S==NULL) return ERROR; e = S-\u0026gt; data; p = S; S = S-\u0026gt; next; delete p; return OK; } 取链栈栈顶元素 1 2 3 4 5 SElemType GetTop(LinkStack S) { if (S==NULL) exit(1)； else return S–\u0026gt;data; } 栈与递归 递归的定义：若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程\n函数调用过程 时间效率：与递归树的结点数成正比 $$ \\def \\bar#1{#1^n} O(\\bar{2}) $$\n空间效率：与递归树的深度成正比 $$ \\def \\bar#1{n} O(\\bar{}) $$\n递归的优缺点 优点：结构清晰，程序易读\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n队列的表示和操作的实现 1 2 3 4 5 6 #define M 100 //最大队列长度 Typedef struct { QElemType *base; //初始化的动态分配存储空间 int front; //头指针 int rear; //尾指针 }SqQueue; 一维队列：\n存在问题：无法确认是否真溢出\r循环队列：\n循环队列初始化 1 2 3 4 5 6 Status InitQueue (SqQueue \u0026amp;Q){ Q.base =new QElemType[MAXQSIZE] if(!Q.base) exit(OVERFLOW); Q.front=Q.rear=0; return OK; } 求循环队列的长度 1 2 3 int QueueLength (SqQueue Q){ return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; } 循环队列入队 1 2 3 4 5 6 Status EnQueue(SqQueue \u0026amp;Q,QElemType e){ if((Q.rear+1)%MAXQSIZE==Q.front) return ERROR; Q.base[Q.rear]=e; Q.rear=(Q.rear+1)%MAXQSIZE; return OK; } 循环队列出队 1 2 3 4 5 6 Status DeQueue (LinkQueue \u0026amp;Q,QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; e=Q.base[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; return OK; } *链队列\n链队列初始化 1 2 3 4 5 6 Status InitQueue (LinkQueue \u0026amp;Q){ Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-\u0026gt;next=NULL; return OK; } 销毁链队列 1 2 3 4 5 6 7 Status DestroyQueue (LinkQueue \u0026amp;Q){ while(Q.front){ Q.rear=Q.front-\u0026gt;next; free(Q.front); Q.front=Q.rear; } return OK; } 判断链队列是否为空 1 2 3 Status QueueEmpty (LinkQueue Q){ return (Q.front==Q.rear); } 求链队列的队头元素 1 2 3 4 5 Status GetHead (LinkQueue Q, QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; e=Q.front-\u0026gt;next-\u0026gt;data; return OK; } 链队列入队 1 2 3 4 5 6 7 8 Status EnQueue(LinkQueue \u0026amp;Q,QElemType e){ p=(QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-\u0026gt;data=e; p-\u0026gt;next=NULL; Q.rear-\u0026gt;next=p; Q.rear=p; return OK; } 链队列出队 1 2 3 4 5 6 7 8 9 Status DeQueue (LinkQueue \u0026amp;Q,QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; p=Q.front-\u0026gt;next; e=p-\u0026gt;data; Q.front-\u0026gt;next=p-\u0026gt;next; if(Q.rear==p) Q.rear=Q.front; delete p; return OK; } ","date":"2023-02-14T00:00:00Z","image":"https://sryasuka.fun/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/Stacks_and_queues_huda7fe0680db057bb15a758c1801f5cde_24118_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列"},{"content":"线性表 目标： 1. 线性结构特点\r2. 顺序表的定义，创建，插入，删除\r3. 链表的定义，创建，插入，删除\r4. 场景分析\r特点 用数据元素的有限序列表示 同一线性表中的元素必定具有相同的特性\n顺序表 顺序表又称 顺序存储结构/顺序映像\n定义: 逻辑上相邻，物理上也相邻\n存储方法: 用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现。\n顺序表的类型定义 示例：\n顺序表的基本算法操作 初始化 1 2 3 4 5 6 Status InitList_Sq(SqList \u0026amp;L){ //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0;\t//空表长度为0 return OK; } //参数使用引用 1 2 3 4 5 6 Status InitList_Sq(SqList *L){ //构造一个空的顺序表L L-\u0026gt; elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(! L-\u0026gt; elem) exit(OVERFLOW); //存储分配失败 L-\u0026gt; length=0;\t//空表长度为0 return OK; } //参数使用指针 取值（根据位置i获取对应位置的数据元素） 1 2 3 4 5 6 7 int GetElem(SqList L,int i,ElemType \u0026amp;e) { if (i\u0026lt;1||i\u0026gt;L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e=L.elem[i-1]; //第i-1的单元存储着第i个数据 return OK; } 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 int LocateELem(SqList L,ElemType e) { for (i=0;i\u0026lt; L.length;i++) if (L.elem[i]==e) return i+1; return 0; } 插入（插在第 i 个结点之前） （1）判断插入位置i 是否合法。\n（2）判断顺序表的存储空间是否已满。\n（3）将第n至第i 位的元素依次向后移动一个位置，空出第i个位置。\n（4）将要插入的新元素e放入第i个位置。\n（5）表长加1，插入成功返回OK。\n1 2 3 4 5 6 7 8 9 Status ListInsert_Sq(SqList \u0026amp;L,int i ,ElemType e){ if(i\u0026lt;1 || i\u0026gt;L.length+1) return ERROR;\t//i值不合法 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(j=L.length-1;j\u0026gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length;\t//表长增1 return OK; } 删除（删除第i个节点） （1）判断删除位置i 是否合法（合法值为1≤i≤n）。\n（2）将欲删除的元素保留在e中。\n（3）将第i+1至第n 位的元素依次向前移动一个位置。\n（4）表长减1，删除成功返回OK。\n1 2 3 4 5 6 7 Status ListDelete_Sq(SqList \u0026amp;L,int i){ if((i\u0026lt;1)||(i\u0026gt;L.length)) return ERROR;\t//i值不合法 for (j=i;j\u0026lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; } 顺序表的特点 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致\n在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等　这种存取方法称为随机存取法\n优点：\n存储密度大（结点本身所占存储量/结点结构所占存储量）\n可以随机存取表中任一元素\n缺点：\n在插入、删除某一元素时，需要移动大量元素\n浪费存储空间\n属于静态存储形式，数据元素的个数不能自由扩充\n顺序表的时间，空间复杂度 查找、插入、删除算法的平均时间复杂度为 O(n)\n顺序表的空间复杂度S(n)=O(1) （没有占用辅助空间）\n链表 结点在存储器中的位置是任意的即逻辑上相邻的数据元素在物理上不一定相邻\n通过指针进行实现\n各结点由两个域组成：\n数据域：存储元素数值数据\n指针域：存储直接后继结点的存储位置\n链表的分类：单链表，双链表，循环链表\n单链表：结点只有一个指针域。\n双链表：结点有两个指针域的链表\n循环链表：首尾相接的链表\n头指针，头结点和首元结点 链表表头设置头结点的好处：\n方便首元结点处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;\n便于空表和非空表的统一处理 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\nPS：头结点可以为空，也可以存储线性表长度的附加信息，不会被记录长度\n单链表的定义与实现 单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名\n若头指针名是L，则把链表称为表L\nLNode * 与 LinkList 等价\n单链表的基本算法操作 初始化 1 2 3 4 5 Status InitList_L(LinkList \u0026amp;L){ L=new LNode; L-\u0026gt;next=NULL;　return OK; } 销毁 1 2 3 4 5 6 7 8 9 10 Status DestroyList_L(LinkList \u0026amp;L){ LinkList p; while(L) { p=L; L=L-\u0026gt;next; delete p; } return OK; } 清空 1 2 3 4 5 6 7 8 9 Status ClearList(LinkList \u0026amp; L){ // 将L重置为空表 LinkList p,q; p=L-\u0026gt;next; //p指向第一个结点 while(p) //没到表尾 { q=p-\u0026gt;next; delete p; p=q; } L-\u0026gt;next=NULL; //头结点指针域为空 return OK; } 求表长 1 2 3 4 5 6 7 8 9 10 int ListLength_L(LinkList L){ //返回L中数据元素个数 LinkList p; p=L-\u0026gt;next; //p指向第一个结点 i=0; while(p){//遍历单链表,统计结点数 i++; p=p-\u0026gt;next; } return i; } 判断表是否为空 1 2 3 4 5 6 7 int ListEmpty(LinkList L){ //若L为空表，则返回1，否则返回0 if(L-\u0026gt;next) //非空 return 0; else return 1; } 取值（根据位置i获取相应位置数据元素的内容） 1 2 3 4 5 6 7 8 9 Status GetElem_L(LinkList L,int i,ElemType \u0026amp;e){ p=L-\u0026gt;next;j=1; //初始化 while(p\u0026amp;\u0026amp;j\u0026lt;i){\t//向后扫描，直到p指向第i个元素或p为空 p=p-\u0026gt;next; ++j; } if(!p || j\u0026gt;i)return ERROR; //第i个元素不存在 e=p-\u0026gt;data; //取第i个元素 return OK; }//GetElem_L 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 LNode *LocateELem_L (LinkList L，Elemtype e) { //返回L中值为e的数据元素的地址，查找失败返回NULL p=L-\u0026gt;next; while(p \u0026amp;\u0026amp;p-\u0026gt;data!=e) p=p-\u0026gt;next; return p; } 插入（插在第 i 个结点之前） 1 2 3 4 5 6 7 8 9 10 Status ListInsert_L(LinkList \u0026amp;L,int i,ElemType e){ p=L;j=0; while(p\u0026amp;\u0026amp;j\u0026lt;i−1){p=p-\u0026gt;next;++j;}\t//寻找第i−1个结点 if(!p||j\u0026gt;i−1)return ERROR;\t//i大于表长 + 1或者小于1 s=new LNode;\t//生成新结点s s-\u0026gt;data=e; //将结点s的数据域置为e s-\u0026gt;next=p-\u0026gt;next;\t//将结点s插入L中 p-\u0026gt;next=s; return OK; }//ListInsert_L 删除（删除第 i 个结点） 1 2 3 4 5 6 7 8 9 10 11 12 Status ListDelete_L(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ p=L;j=0; while(p-\u0026gt;next \u0026amp;\u0026amp;j\u0026lt;i-1){//寻找第i个结点，并令p指向其前驱 p=p-\u0026gt;next; ++j; } if(!(p-\u0026gt;next)||j\u0026gt;i-1) return ERROR; //删除位置不合理 q=p-\u0026gt;next; //临时保存被删结点的地址以备释放 p-\u0026gt;next=q-\u0026gt;next; //改变删除结点前驱结点的指针域 e=q-\u0026gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; }//ListDelete_L 链表的特点 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等\n这种存取元素的方法被称为顺序存取法\n优点:\n数据元素的个数可以自由扩充\n插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高\n缺点：\n存储密度小\n存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）\n链表的时间，空间复杂度 查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。\n插入和删除: 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为 O(1)。\n如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 。\n*单链表的建立 方法一：前插法\n1 2 3 4 5 6 7 8 9 10 void CreateList_F(LinkList \u0026amp;L,int n){ L=new LNode; L-\u0026gt;next=NULL; //先建立一个带头结点的单链表 for(i=n;i\u0026gt;0;--i){ p=new LNode; //生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; //插入到表头 } }//CreateList_F 方法二：后插法\n1 2 3 4 5 6 7 8 9 10 11 12 void CreateList_L(LinkList \u0026amp;L,int n){ //正位序输入n个元素的值，建立带表头结点的单链表L L=new LNode; L-\u0026gt;next=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u0026lt;n;++i){ p=new LNode;\t//生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=NULL; r-\u0026gt;next=p; //插入到表尾 r=p; //r指向新的尾结点 } }//CreateList_L *双向链表和循环链表的共性特点 循环链表和双向链表是两种常见的链式存储结构，它们的共性如下：\n都是链式存储：链式存储是指线性数据结构的一种存储方式，在这种方式中，数据不是顺次存储在内存单元中，而是通过一个指针将相邻的数据连接在一起。\n都可以实现动态的数据存储：链式存储的线性结构可以随着数据的添加和删除动态变化，避免因为数据量固定导致的内存浪费。\n都是非连续存储：链式存储的数据不是顺次存储在内存单元中，而是分散存储在各个不同的内存单元中，因此是非连续的。\n循环链表的特点：\n循环：循环链表是一种特殊的链式存储结构，其特殊之处在于，最后一个数据元素的指针指向链表的第一个元素，实现了循环结构。\n方便遍历：由于循环链表结构中的数据元素是相互连接的，因此，可以方便地从一个数据元素遍历到另一个数据元素。\n双向链表的特点：\n双向链接双向链表是一种特殊的链式存储结构，每个数据元素同时包含了前驱和后继的指针，使得可以从前面和后面同时遍历链表。\n方便插入和删除：由于双向链表中每个数据元素都包含了前驱和后继的指针，因此，可以方便地在链表的任意位置插入和删除数据元素。\n顺序表和链表的比较 ","date":"2023-02-12T00:00:00Z","image":"https://sryasuka.fun/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/Linear_tables_hua6ee4ed3cf660c859c134ad90be5e6ce_35023_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"线性表"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://sryasuka.fun/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://sryasuka.fun/p/test-chinese/","title":"Chinese Test"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://sryasuka.fun/p/","title":""}]