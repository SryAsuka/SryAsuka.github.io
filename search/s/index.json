[{"content":"串 串的定义 串(String)\u0026mdash;-零个或多个字符组成的有限序列\n串的类型定义、存储结构及运算 基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 (1) StrAssign (\u0026amp;T,chars) //串赋值 (2) StrCompare (S,T) //串比较 (3) StrLength (S) //求串长 (4) Concat(\u0026amp;T,S1,S2) //串联 (5) SubString(\u0026amp;Sub,S,pos,len) //求子串 (6) StrCopy(\u0026amp;T,S) //串拷贝 (7) StrEmpty(S) //串判空 (8) ClearString (\u0026amp;S) //清空串 (9) Index(S,T,pos) //子串的位置 (11) Replace(\u0026amp;S,T,V) //串替换 (12) StrInsert(\u0026amp;S,pos,T) //子串插入 (13) StrDelete(\u0026amp;S,pos,len) //子串删除 (14) DestroyString(\u0026amp;S) //串销毁 串的存储结构 顺序存储：\n1 2 3 4 5 typedef struct{ char *ch; //若串非空,则按串长分配存储区, //否则ch为NULL int length; //串长度 }HString; 链式存储：\n1 2 3 4 5 6 7 8 9 10 #define CHUNKSIZE 80 //可由用户定义的块大小 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; //串的头指针和尾指针 int curlen; //串的当前长度 }LString; 链式存储的优缺点\n优点：操作方便 缺点：存储密度较低 PS: 存储密度 = 串值所占的存储位/实际分配的存储位\n可以使用可将多个字符存放在一个结点中，以克服其缺点\n串的模式匹配算法 BF算法 :\nIndex(S,T,pos)\n将主串的第pos个字符和模式的第一个字符比较，若相等，继续逐个比较后续字符； 若不等，从主串的下一字符起，重新与模式的第一个字符比较。\n直到主串的一个连续子串字符序列与模式相等 。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。\n否则，匹配失败，返回值 0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Index(SString S,SString T,int pos){ int i=pos; int j=1; while (i \u0026lt;= S[0] \u0026amp;\u0026amp; j \u0026lt;= T[0] ){ if ( S[i] = T[j] ){ ++i; ++j; } else{ i=i-j+2; j=1; } if( j \u0026gt; T[0] ) return i - T[0]; else return 0; } } BF算法时间复杂度\n例： S=‘0000000001’，T=‘0001’，pos=1\n若n为主串长度，m为子串长度，最坏情况是\n主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次 最后m位也各比较了1次 总次数为：(n-m) * m+m＝(n-m+1) * m\n若m \u0026laquo; n，则算法复杂度O(n*m)\n数组 本章的数组既可以是顺序的，也可以是链式结构，用户可根据需要选择。\n基本操作：\n```\r(1) InitArray (\u0026amp;A,n,bound1, boundn) //构造数组A\r(2) DestroyArray (\u0026amp;A) // 销毁数组A\r(3) Value(A,\u0026amp;e,index1,…,indexn) //取数组元素值\r(4) Assign (A,\u0026amp;e,index1,…,indexn) //给数组元素赋值\r```\r一维数组\n二维数组\n行序优先的表示：\n广义表 广义表（列表）: n (\u0026gt;=0)个表元素组成的有限序列，记作LS = (a0, a1, a2, …, an-1)\nLS是表名，ai是表元素，它可以是表 (称为子表)，可以是数据元素(称为原子)。\nPS:n为表的长度。n = 0 的广义表为空表\n广义表的基本运算 求表头GetHead(L)：非空广义表的第一个元素，可以是一个单元素，也可以是一个子表 求表尾GetTail(L)：非空广义表除去表头元素以外其它元素所构成的表。表尾一定是一个表 练习 A=(a,b,(c,d),(e,(f,g)))\nGetHead(GetTail(GetHead(GetTail(GetTail(A))))) = ?\n解题过程\nGetTail(A)= (b,(c,d),(e,(f,g))) = S GetTail(S)=((c,d),(e,(f,g)))=S1 GetHead(S1)=(c,d)=S2 GetTail(S2)=(d)=S3 GetHead(S3)=d 广义表的特点 有次序性: 一个直接前驱和一个直接后继 有长度 ＝表中元素个数 有深度 ＝表中括号的重数 可递归: 自己可以作为自己的子表 可共享: 可以为其他广义表所共享 ","date":"2023-02-25T00:00:00Z","image":"https://sryasuka.fun/p/%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/SAAGT_hu2dc5c42be9f281dc0f35b02f70637176_36037_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","title":"串、数组和广义表"},{"content":"图的定义和基本术语 图：Graph=(V,E)\nV：顶点(数据元素)的有穷非空集合； E：边的有穷集合。 有向图： 每条边都是有方向的 无向图： 每条边都是无方向的 完全图：任意两个点都有一条边相连\n无向完全图：n(n-1)/2 条边 有向完全图：n(n-1) 条边 稀疏图：有很少边或弧的图。\n稠密图：有较多边或弧的图。\n网：边/弧带权的图。\n邻接：有边/弧相连的两个顶点之间的关系。\n存在(vi, vj)，则称vi和vj互为邻接点； 存在\u0026lt;vi, vj\u0026gt;，则称vi邻接到vj， vj邻接于vi 关联(依附)：边/弧与顶点之间的关系。\n存在(vi, vj)/ \u0026lt;vi, vj\u0026gt;， 则称该边/弧关联于vi和vj 顶点的度：与该顶点相关联的边的数目，记为TD(v)\n在有向图中, 顶点的度等于该顶点的入度与出度之和。\n顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v) 顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v) 有向树：仅1个顶点的入度为0,其余顶点的入度均为1\n路径：接续的边构成的顶点序列。\n路径长度：路径上边或弧的数目/权值之和。\n回路(环)：第一个顶点和最后一个顶点相同的路径。\n简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。\n简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。\n连通图（强连通图）：\n在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。\n图的类型定义 CreateGraph(\u0026amp;G,V,VR)\n初始条件：V是图的顶点集，VR是图中弧的集合。 操作结果：按V和VR的定义构造图G。 DFSTraverse(G)\n初始条件：图G存在。 操作结果：对图进行深度优先遍历。 BFSTraverse(G)\n初始条件：图G存在。 操作结果：对图进行广度优先遍历。 邻接矩阵 邻接矩阵：建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）\n邻接矩阵的特点 优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。 缺点：n个顶点需要n*n个单元存储边;空间效率为O(n2)。 对稀疏图而言尤其浪费空间。 邻接矩阵的储存表示 1 2 3 4 5 6 7 8 9 #define MaxInt 32767 //表示极大值，即∞ #define MVNum 100 //最大顶点数 typedef char VerTexType; //假设顶点的数据类型为字符型 typedef int ArcType; //假设边的权值类型为整型 typedef struct{ VerTexType vexs[MVNum]; //顶点表 ArcType arcs[MVNum][MVNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数 }AMGraph; 采用邻接矩阵表示法创建无向网 算法思路：\n输入总顶点数和总边数。 依次输入点的信息存入顶点表中。 初始化邻接矩阵，使每个权值初始化为极大值。 构造邻接矩阵。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Status CreateUDN(AMGraph \u0026amp;G){ //采用邻接矩阵表示法，创建无向网G cin\u0026gt;\u0026gt;G.vexnum\u0026gt;\u0026gt;G.arcnum; //输入总顶点数，总边数 for(i = 0; i\u0026lt;G.vexnum; ++i) cin\u0026gt;\u0026gt;G.vexs[i]; //依次输入点的信息 for(i = 0; i\u0026lt;G.vexnum;++i) //初始化邻接矩阵，边的权值均置为极大值 for(j = 0; j\u0026lt;G.vexnum;++j) G.arcs[i][j] = MaxInt; for(k = 0; k\u0026lt;G.arcnum;++k){ //构造邻接矩阵 cin\u0026gt;\u0026gt;v1\u0026gt;\u0026gt;v2\u0026gt;\u0026gt;w; //输入一条边依附的顶点及权值 i = LocateVex(G, v1); j = LocateVex(G, v2); //确定v1和v2在G中的位置 G.arcs[i][j] = w; //边\u0026lt;v1, v2\u0026gt;的权值置为w G.arcs[j][i] = G.arcs[i][j]; //置\u0026lt;v1, v2\u0026gt;的对称边\u0026lt;v2, v1\u0026gt;的权值为w }//for return OK; }//CreateUDN 1 2 3 4 5 6 7 8 int LocateVex(MGraph G,VertexType u) {//存在则返回u在顶点表中的下标;否则返回-1 int i; for(i=0;i\u0026lt;G.vexnum;++i) if(u==G.vexs[i]) return i; return -1; } 邻接表 邻接表的特点 优点：空间效率高，容易寻找顶点的邻接点； 缺点：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。 邻接表的储存表示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define MVNum 100 //最大顶点数 typedef struct ArcNode{ //边结点 int adjvex; //该边所指向的顶点的位置 struct ArcNode * nextarc; //指向下一条边的指针 OtherInfo info; //和边相关的信息 }ArcNode; typedef struct VNode{ VerTexType data; //顶点信息 ArcNode * firstarc; //指向第一条依附该顶点的边的指针 }VNode, AdjList[MVNum]; //AdjList表示邻接表类型 typedef struct{ AdjList vertices; //邻接表 int vexnum, arcnum; //图的当前顶点数和边数 }ALGraph; 采用邻接表表示法创建无向网 输入总顶点数和总边数。 依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。 创建邻接表。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Status CreateUDG(ALGraph \u0026amp;G){ //采用邻接表表示法，创建无向图G cin\u0026gt;\u0026gt;G.vexnum\u0026gt;\u0026gt;G.arcnum; //输入总顶点数，总边数 for(i = 0; i\u0026lt;G.vexnum; ++i){ //输入各点，构造表头结点表 cin\u0026gt;\u0026gt; G.vertices[i].data; //输入顶点值 G.vertices[i].firstarc=NULL; //初始化表头结点的指针域为NULL }//for for(k = 0; k\u0026lt;G.arcnum;++k){ //输入各边，构造邻接表 cin\u0026gt;\u0026gt;v1\u0026gt;\u0026gt;v2; //输入一条边依附的两个顶点 i = LocateVex(G, v1); j = LocateVex(G, v2); p1=new ArcNode; //生成一个新的边结点*p1 p1-\u0026gt;adjvex=j; //邻接点序号为j p1-\u0026gt;nextarc= G.vertices[i].firstarc; G.vertices[i].firstarc=p1; //将新结点*p1插入顶点vi的边表头部 p2=new ArcNode; //生成另一个对称的新的边结点*p2 p2-\u0026gt;adjvex=i; //邻接点序号为i p2-\u0026gt;nextarc= G.vertices[j].firstarc; G.vertices[j].firstarc=p2; //将新结点*p2插入顶点vj的边表头部 }//for return OK; }//CreateUDG 图的遍历 深度优先的DFS算法\n1 2 3 4 5 6 7 8 9 void DFS(ALGraph G, int v){ //图G为邻接表类型 cout\u0026lt;\u0026lt;v; visited[v] = true; //访问第v个顶点 p= G.vertices[v].firstarc; //p指向v的边链表的第一个边结点 while(p!=NULL){ //边结点非空 w=p-\u0026gt;adjvex; //表示w是v的邻接点 if(!visited[w]) DFS(G, w); //如果w未访问，则递归调用DFS p=p-\u0026gt;nextarc; //p指向下一个边结点 } } 广度优先的BFS算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 void BFS (Graph G, int v){ //按广度优先非递归遍历连通图G cout\u0026lt;\u0026lt;v; visited[v] = true; //访问第v个顶点 InitQueue(Q); //辅助队列Q初始化，置空 EnQueue(Q, v); //v进队 while(!QueueEmpty(Q)){ //队列非空 DeQueue(Q, u); //队头元素出队并置为u for(w = FirstAdjVex(G, u); w\u0026gt;=0; w = NextAdjVex(G, u, w)) if(!visited[w]){ //w为u的尚未访问的邻接顶点 cout\u0026lt;\u0026lt;w; visited[w] = true;\tEnQueue(Q, w); //w进队 }//if }//while }//BFS 最小生成树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void ShortestPath_DIJ(AMGraph G, int v0){ //用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 n=G.vexnum; //n为G中顶点的个数 for(v = 0; v\u0026lt;n; ++v){ //n个顶点依次初始化 S[v] = false; //S初始为空集 D[v] = G.arcs[v0][v]; //将v0到各个终点的最短路径长度初始化 if(D[v]\u0026lt; MaxInt) Path [v]=v0; //v0和v之间有弧，将v的前驱置为v0 else Path [v]=-1; //如果v0和v之间无弧，则将v的前驱置为-1 }//for S[v0]=true; //将v0加入S D[v0]=0; //源点到源点的距离为0 /*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/ for(i=1;i\u0026lt;n; ++i){ //对其余n−1个顶点，依次进行计算 min= MaxInt; for(w=0;w\u0026lt;n; ++w) if(!S[w]\u0026amp;\u0026amp;D[w]\u0026lt;min) {v=w; min=D[w];} //选择一条当前的最短路径，终点为v S[v]=true; //将v加入S for(w=0;w\u0026lt;n; ++w) //更新从v0出发到集合V−S上所有顶点的最短路径长度 if(!S[w]\u0026amp;\u0026amp;(D[v]+G.arcs[v][w]\u0026lt;D[w])){ D[w]=D[v]+G.arcs[v][w]; //更新D[w] Path [w]=v; //更改w的前驱为v }//if }//for }//ShortestPath_DIJ ","date":"2023-02-25T00:00:00Z","image":"https://sryasuka.fun/p/%E5%9B%BE/Pic_huc140da47fd37f5aa577f04e490961b98_16099_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E5%9B%BE/","title":"图"},{"content":"查找基本概念 查找表: 由同一类型的数据元素（或记录）构成的集合 静态查找表： 查找的同时对查找表不做修改操作（如插入和删除） 动态查找表： 查找的同时对查找表具有修改操作 关键字 记录中某个数据项的值，可用来识别一个记录 主关键字： 唯一标识数据元素 次关键字： 可以标识若干个数据元素 线性表查找 顺序查找 1 2 3 4 int LocateELem(SqList L,ElemType e) { for (i=0;i\u0026lt; L.length;i++) if (L.elem[i]==e) return i+1; return 0;} 改进\n1 2 3 4 5 6 7 int Search_Seq( SSTable ST , KeyType key ){ //若成功返回其位置信息，否则返回0 ST.R[0].key =key; for( i=ST.length; ST.R[ i ].key!=key; - - i ); //不用for(i=n; i\u0026gt;0; - -i) 或 for(i=1; i\u0026lt;=n; i++) return i; } 时间复杂度: O(n) (n+1)/2\n折半查找 1 2 3 4 5 6 7 8 9 int Search_Bin(SSTable ST,KeyType key){ //若找到，则函数值为该元素在表中的位置，否则为0 low=1;high=ST.length;\twhile(low\u0026lt;=high){ mid=(low+high)/2; if(key==ST.R[mid].key) return mid; else if(key\u0026lt;ST.R[mid].key) high=mid-1;//前一子表查找 else low=mid+1; //后一子表查找 }\treturn 0;\t//表中不存在待查元素 } 时间复杂度 O(log2 n)\n不适合用链表适合用顺序表\n分块查找 效率比顺序快比折半慢\n树查找 二叉排序树 二叉排序树或是空树，或是满足如下性质的二叉树：\n若其左子树非空，则左子树上所有结点的值均小于根结点的值； 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值； 其左右子树本身又各是一棵二叉排序树 右图 左分树 6 在 4 下 不是二叉排序树\n1 2 3 4 5 BSTree SearchBST(BSTree T,KeyType key) { if((!T) || key==T-\u0026gt;data.key) return T; else if (key\u0026lt;T-\u0026gt;data.key) return SearchBST(T-\u0026gt;lchild,key);\t//在左子树中继续查找 else return SearchBST(T-\u0026gt;rchild,key); //在右子树中继续查找 } // SearchBST ","date":"2023-02-25T00:00:00Z","image":"https://sryasuka.fun/p/%E6%9F%A5%E6%89%BE/Find_hu7dc183bcb08b1f208801dfb9abfd3438_15594_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E6%9F%A5%E6%89%BE/","title":"查找"},{"content":"ch05 main和初启函数 一个进程的代码由用户代码和内核代码组成，进程的用户代码是从main函数才开始执行的。许多程序运行时，往往需要提供一些信息作为main函数的参数来运行，其典型代表是各个命令行程序。编写带参数的程序时，需要使用带参数的main函数，其原型如下:\nint main(int argc,char **argv)\nint main(int argc, char *argv[])\n进程的真正启动点是系统提供的一个初启函数，该函数位于名为crt0.o的文件中。当编译C程序时，链接器ld会将此文件与C程序文件装配在一起形成可执行文件，并指定该初启函数为程序的开始执行地址。\ngetopt中的“模板” 如果程序中的命令行参数遵守前面列出的语法规定，则可以用函数getopt()来读取其中的选项。\n1 2 3 4 #include \u0026lt;unistd.h\u0026gt; int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; getopt()从argc和argv所指定的参数表中获取下一选项。\n参数optstring是一字符串，它给出对该程序而言合法的选项字符。在此字符串中的选项字符可以跟有冒号“:”指出它要求带有值。例如，字符串“if:ls”表示允许选项-i、-f、-l和-s，且-f要求跟有一个值。\nch06 进程抽象 进程：\n程序是指令和数据的集合。可执行程序是文本形式程序的机器版本，是指令和数据的二进制处理机表示。\n运行一个程序就得到一个进程。哪怕两个用户同时通过网络登录运行同一计算机上的同一个程序bash，他们也创建的是不同的进程。尽管这两个进程会共享程序的代码和数据，但它们的运行有自己独立的流程，各自分配的系统资源也是不一样的，因此是不同的进程\n进程是计算机科学中最深刻最成功的概念之一。\n在编程中，进程提供给应用程序2个关键抽象：\n一个独立的逻辑控制流，它提供一个假象，使程序觉得在独占地使用处理器。(分时调度技术，上下文切换) 一个私有的地址空间，它提供一个假象，使程序觉得在独占地使用存储器系统。(虚拟存储器，上下文切换) 进程并发 上下文 Linux进程的状态 PID与PCB 每个进程都有一个按顺序分配的整型编号，称为进程标识符或PID，内核代码通过PID来标识不同的进程，同时PID也是内核提供给用户程序的接口，用户程序可以通过PID来操纵进程.\n在32bit的平台中，PID是int类型，但为了与传统硬件平台(16位)兼容，允许的最大编号为32767。当创建第32768号进程时，必须重新从300开始使用已闲置的进程号。\n除了第一个进程(进程0，也叫init_task进程)是用“手工”创建之外，其余的都是已有进程使用fork系统调用创建的新进程。init_task进程创建了PID为1的init进程，它是后续所有进程的祖先。\nexce函数 fork函数 5种进程终止 对于进程，有5种方式使其终止：\n正常终止：从main返回、调用exit、调用_exit。 异常终止：调用abort、由一个信号终止。 通过main函数返回而终止进程是常用的方法。当main函数返回后，由初启函数crt0.o调用exit函数终止进程。如果用C来写该初启过程，则它将按如下方式调用main：\nexit(main(argc, argv));\n程序中也常常会用到exit，但较少用到_exit。事实上，这两个函数均终止进程，不同的是_exit直接进入到内核；而exit则会先执行一些清理工作，然后调用_exit进入到内核，因此不推荐应用程序直接调用_exit。\nwait 孤儿进程与僵尸进程 管道 管道概述 pipe pipe常见方法 命名管道 ","date":"2023-02-22T00:00:00Z","image":"https://sryasuka.fun/p/linux-05.06.13/Linux_ch05_hu2e1ab1ce08434c0cf141c387658b4781_68554_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/linux-05.06.13/","title":"Linux 05.06.13"},{"content":"文件结构 在Linux文件系统中，每一个存放在磁盘上的文件由两部分组成：\n数据块－实际存放文件数据的磁盘块 i-node－描述文件属性的数据结构，常称为索引节点 i-node: 一个固定长度的数据结构，含有关于文件的大部分属性信息，如文件数据块的索引分配表(后面阐述)、权限、文件类型、大小、访问日期等等。\n每一个i-node有其自己的数值标识，称为i-node number(索引节点号)，一个文件只能通过其inode节点进行访问。\n为了便于用户使用，通常还会对一个文件进行命名，文件名实际上是文件的用户接口。\nLinux中七种文件类型 普通文件 (Regular file)：存储文本、图像、音频或二进制数据等常规文件的文件类型。\n目录 (Directory)：存储其他文件和目录的文件类型，可以包含其他目录和子目录。\n符号链接 (Symbolic link)：类似于Windows中的快捷方式，是指向另一个文件或目录的指针。\n套接字 (Socket)：用于进程间通信的特殊文件类型。\n块设备文件 (Block device file)：提供对块设备（如硬盘、USB设备等）的访问的文件类型。\n字符设备文件 (Character device file)：提供对字符设备（如串行端口、打印机等）的访问的文件类型。\n管道 (Named pipe)：用于进程间通信的一种文件类型，可以在不同的进程之间传输数据。\nchmod chmod 一条命令，用于更改文件或目录的权限。\n\u0026ldquo;chmod\u0026quot;代表\u0026quot;change mode\u0026rdquo;。使用chmod命令可以更改用户（所有者）、群组和其他用户的文件或目录权限。\n目录 硬链接和软链接 12个文件访问权限 文件所有者的权限 (User permissions)：通常表示为文件权限字符串中的前三个字符。这个权限定义了文件所有者的权限。\n文件所在组的权限 (Group permissions)：通常表示为文件权限字符串中的第四到第六个字符。这个权限定义了文件所在组的用户的权限。\n其他用户的权限 (Other permissions)：通常表示为文件权限字符串中的第七到第九个字符。这个权限定义了其他用户（不属于文件所在组，也不是文件所有者）的权限。\n目录权限规则 因目录也是文件，对目录读权限指可查看目录中的文件列表；对目录写权限指可删除移动创建目录里的文件或目录，即允许修改目录文件内容(对普通文件有写权限并不代表可删除该文件，只有该文件所在的目录有写权限才可删除该文件)；对目录有执行权限表示可进入该目录(检索权限)。\n用户必须拥有目录的执行权限才能进入该目录并访问其中的文件和子目录。因此，即使用户拥有目录中某个文件的读权限，如果目录本身没有执行权限，用户也无法访问该文件。\n实际用户(组)ID、有效用户(组)ID和设置用户(组)ID 掩码(umask) 文件模式创建掩码（简称umask）会对这些设置进行修改，umask是一种进程属性，通常继承自其父shell，用户可以使用shell内置命令umask来改变shell进程的umask，从而控制在shell下运行程序的umask.\nLinux系统默认创建文件的权限位是0666(\u0026mdash;rw- rw- rw-)，默认创建目录的权限位是0777(\u0026mdash;rwxrwxrwx)，当umask值为0022(\u0026mdash; \u0026mdash; -w- -w-)时，实际创建文件的权限位是0644，目录的权限位是0755。\n","date":"2023-02-20T00:00:00Z","image":"https://sryasuka.fun/p/linux_ch04/Linux_ch04_hua64814b440d9e44068e8193d93d24b21_80528_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/linux_ch04/","title":"文件操作"},{"content":"流和文件描述符及之间的关系 在计算机操作系统中，流和文件描述符是紧密相关的概念，它们之间的关系如下：\n文件描述符：文件描述符是一个非负整数，用于标识打开文件或其他输入/输出设备的唯一标识符。在Unix和类Unix系统中，每个打开的文件或设备都被分配一个文件描述符，它是操作系统内部使用的一个数字，程序可以通过文件描述符来访问文件或设备。\n流：流是一个抽象的概念，它表示从程序中一个地方到另一个地方的数据流动。流可以是输入流、输出流或输入/输出流，它们在程序中通过流对象来实现。流对象封装了文件描述符及其相关操作，使得程序可以以更高级别的方式进行输入和输出操作，而不需要直接操作文件描述符。\n流和文件描述符的关系：在Unix和类Unix系统中，每个流都与一个文件描述符相关联。例如，标准输入流stdin通常与文件描述符0相关联，标准输出流stdout通常与文件描述符1相关联，标准错误流stderr通常与文件描述符2相关联。在程序中使用流对象来进行输入/输出操作时，操作系统会自动将流对象转换为与其相关联的文件描述符来进行底层的读写操作。\n三个标准流 三个标准流通常指的是：标准输入流（stdin）、标准输出流（stdout）和标准错误流（stderr），在计算机操作系统中被广泛使用。\n标准输入流（stdin）：这是程序从用户那里获取输入数据的标准方式。标准输入流通常通过键盘输入，但也可以通过文件、管道或其他设备输入。在Linux和Unix操作系统中，可以使用重定向符号 \u0026ldquo;\u0026lt;\u0026rdquo; 来将一个文件中的内容输入到标准输入流中。\n标准输出流（stdout）：这是程序输出数据的标准方式。标准输出流通常是显示在屏幕上的文本信息，但也可以重定向到文件中。在Linux和Unix操作系统中，可以使用重定向符号 \u0026ldquo;\u0026gt;\u0026rdquo; 来将标准输出流的内容写入一个文件中。\n标准错误流（stderr）：这是程序输出错误信息的标准方式。标准错误流通常是显示在屏幕上的红色文本信息，以便用户注意到它们。与标准输出流不同，标准错误流的输出不会被重定向到文件中，除非专门使用特定的符号 \u0026ldquo;2\u0026gt;\u0026rdquo; 进行重定向。\n打开和关闭流 流缓冲区和内核缓冲区 流缓冲区：流缓冲区是在程序内部使用的一个缓冲区，它存储了要写入或读取的数据。当程序进行输出操作时，数据首先被写入到流缓冲区中，直到缓冲区满或程序调用了flush()函数或关闭流时才将数据写入到内核缓冲区中。当程序进行输入操作时，数据也是首先从内核缓冲区读取到流缓冲区中，直到缓冲区为空或程序读取了足够的数据时才会再次从内核缓冲区中读取数据。\n内核缓冲区：内核缓冲区是操作系统内核使用的一个缓冲区，它用于存储要写入或读取的数据。当程序进行输入操作时，数据从流缓冲区写入到内核缓冲区中，然后由内核将数据写入到磁盘或网络中。当程序进行输出操作时，数据首先从磁盘或网络中读取到内核缓冲区中，然后由内核将数据从内核缓冲区中复制到流缓冲区中，供程序读取。\n总体上，流缓冲区是程序内部使用的缓冲区，它可以提高输入/输出操作的效率。内核缓冲区是操作系统内核使用的缓冲区，它可以提高磁盘和网络读写的效率。流缓冲区和内核缓冲区的关系是：程序将数据写入到流缓冲区中，然后由内核将数据从流缓冲区复制到内核缓冲区中；或者程序从内核缓冲区中读取数据，然后将数据存储到流缓冲区中。\n流缓冲区类型 文件描述符表、打开文件表和i-node表 在 Unix/Linux 系统中，文件是使用文件描述符（file descriptor）来进行操作的。文件描述符是一个整数，它代表一个文件被打开后在内核中的一个唯一标识符。当应用程序打开一个文件时，内核会分配一个文件描述符，并使用该文件描述符来标识该文件。文件描述符表、打开文件表和 i-node 表是三个与文件操作密切相关的概念，它们分别记录了文件描述符、打开文件和文件在磁盘上的存储位置。\n文件描述符表：文件描述符表是每个进程都有的一个表，它记录了进程中每个打开的文件描述符与内核中的文件描述符之间的映射关系。当应用程序打开一个文件时，内核会分配一个文件描述符，并将其添加到文件描述符表中，以便应用程序在之后的操作中可以使用该文件描述符来标识该文件。\n打开文件表：打开文件表是内核中的一个表，它记录了所有当前被打开的文件的信息，包括文件描述符、文件偏移量、读写模式、文件状态等等。当应用程序打开一个文件时，内核会在打开文件表中创建一个新的表项，并将该表项与文件描述符关联起来。\ni-node 表：i-node 表是在磁盘上维护的一个表，它记录了文件的所有属性和存储位置。每个文件在 i-node 表中都有一个唯一的 i-node 号码，该号码与文件的所有属性和存储位置相关联。当应用程序打开一个文件时，内核会通过文件的 i-node 号码在 i-node 表中查找该文件的相关信息，包括文件类型、访问权限、文件大小、创建时间等等。\n这三个表之间的关系是：文件描述符表中的文件描述符指向打开文件表中的打开文件，而打开文件表中的打开文件又与 i-node 表中的文件相关联。在进行文件操作时，应用程序使用文件描述符来标识文件，内核根据文件描述符在打开文件表中查找相应的打开文件，然后根据打开文件中的 i-node 号码在 i-node 表中查找文件的相关信息。\n","date":"2023-02-20T00:00:00Z","image":"https://sryasuka.fun/p/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E4%BD%8E%E7%BA%A7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Linux_ch02_hu3f69bb3da5628383156e983128f03802_76860_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E4%BD%8E%E7%BA%A7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"标准输入输出/低级输入输出"},{"content":"UNIX标准及两级规范符号度 UNIX是一个操作系统的家族，它的标准是由The Open Group制定的。该标准包括了Single UNIX Specification和POSIX标准两个级别。\nSingle UNIX Specification（SUS）是一份针对UNIX系统的单一规范，它包括了许多开放标准和互操作性标准，用于确保UNIX系统在不同的平台上保持一致的行为。SUS包括了许多子规范，包括基本系统接口、命令和工具、系统管理、应用程序接口等。\nPOSIX标准定义了UNIX系统应该提供的一组接口，这些接口主要用于实现可移植的UNIX应用程序。POSIX标准涵盖了操作系统、编程语言和工具等方面，包括了许多子规范，如POSIX.1，POSIX.2等。\nGPL/LGPL GPL软件允许商业销售，但不允许闭源。它确保了程序代码永远能让所有人自由使用。\nLGPL软件/库允许商业销售，但不允许闭源；但动态链接LGPL库时，允许软件闭源。它主要为库的使用而设计的许可。\nUNIX哲学 小即是美 让每一个程序只做好一件事 尽快建立原型 舍高效率而取可移植性 \u0026ndash;代码可移植 采用纯文本文件存储数据 \u0026ndash;数据可移植 充分利用软件的杠杆效应 使用shell脚本来提高杠杆效应和可移植性 避免强制性的用户界面 灵活性：编程时应尽量考虑到灵活性，尽量避免随意限制字段长度或记录数目。 可重用组件：将应用程序的核心实现为库。 Linux标准 Linux标准是由Linux Standard Base（LSB）组织定义和维护的，它是一个用于确保不同Linux发行版之间二进制兼容性的标准。\nLSB规范定义了一组Linux系统所必须支持的接口、库和命令等，这些接口和命令可用于开发和运行Linux应用程序，从而提高应用程序的可移植性和互操作性。\n内核态和用户态 现代处理器架构一般允许CPU至少在两种不同状态下运行，即内核态和用户态。执行硬件指令可使CPU在两种状态间来回切换。\n进程所能访问的存储位置范围称为虚拟地址空间。与之对应，虚拟内存空间也分为内核空间和用户空间。进程在用户态下运行时，CPU只能访问用户空间，试图访问内核空间的内存将会引起硬件异常。当运行于内核态时，CPU既能访问用户空间内存，也能访问内核空间内存。\nshell提示符结构 常见的 shell有：\nBash(the GNU Bourne-Again Shell)、TC shell、Z shell； //Linux\nBourne shell、Korn shell、C shell //UNIX\n常见的Shell提示符结构包括以下几个组成部分：\n用户名：表示当前登录系统的用户名，可以使用环境变量$USER或$(whoami)来获取。\n主机名：表示当前计算机的主机名或IP地址，可以使用环境变量$HOSTNAME或$(hostname)来获取。\n当前工作目录：表示当前所在的工作目录，可以使用环境变量$PWD来获取。\nShell类型或版本号：表示当前Shell的类型或版本号，可以使用环境变量$SHELL或$BASH_VERSION来获取。\n提示符符号：表示提示符的结束符号，一般为$或#，其中$表示普通用户，#表示超级用户（即root用户）。\nLinux重定向命令 输出重定向（\u0026gt;）：将命令执行的结果输出到一个文件中，可以使用大于符号（\u0026gt;）进行重定向。\n输出追加重定向（\u0026raquo;）：与输出重定向类似，但是将命令执行的结果追加到文件的末尾而不是覆盖原有内容。\n输入重定向（\u0026lt;）：将一个文件中的内容作为命令的输入数据，可以使用小于符号（\u0026lt;）进行重定向。\n文件描述符重定向（\u0026amp;\u0026gt;）：将命令执行的结果同时重定向到标准输出和标准错误输出文件中。\n后台运行命令 在Linux或Unix系统中，可以通过在命令末尾加上\u0026amp;符号，将命令放入后台运行。这种方式可以使得命令在后台执行，而不会占用终端或命令行界面的资源，同时也可以在命令执行过程中继续使用终端或命令行界面进行其他操作。\n后台运行普通命令：在普通命令末尾加上\u0026amp;符号即可将命令放入后台运行 sleep 10 \u0026amp;\n后台运行交互式命令：对于交互式命令，如果直接加上\u0026amp;符号，命令仍然会在前台运行。可以使用nohup命令将交互式命令转为后台运行模式 nohup python3 -i\n挂起已经在前台运行的命令：如果已经在前台运行的命令需要挂起，可以使用Ctrl + Z快捷键将其暂停，并放入后台运行。 1 2 3 tar czf backup.tar.gz /path/to/backup \u0026amp; [1] 12345 $ fg 系统调用和库函数间关系 操作系统具有两种功能：为用户程序提供抽象和管理计算机资源。通常程序和OS之间处理的是前者，例如，创建、写入、读出和删除文件。对用户而言，资源管理部分主要是透明和自动完成的。\n系统调用就是OS的一些内建函数，这些函数为应用程序提供了对计算机资源的抽象，使程序同硬件特性相隔离。从编程的角度看，系统调用的集合及系统调用的内部实现形成了OS的内核。\nC使用_syscall宏，可以直接调用任何系统调用。然而，为了调用方便，标准C库提供了一组针对最常用系统调用的封装(wrapper)函数。封装函数与系统调用通常同名，它将系统调用参数打好包，通过适当的方式陷入内核执行，然后将返回状态传递给应用程序。\n内核是为用户进程运行的，它不是与用户进程平行运行的独立的进程集合，而是每个用户进程的一部分。 用户进程的代码由用户代码(应用程序代码+库)和内核代码组成，执行时常常在用户态和内核态之间切换。\n系统调用通常需要通过内核态和用户态之间的上下文切换来完成，因此效率相对较低，但提供了更底层、更强大的功能。开销大\n库函数通常是在用户态中执行的，因此效率相对较高，但功能相对较弱。开销小。\n在需要对系统进行精确控制时，最好使用系统调用，这可以避免使用库函数带来的一些想不到的问题。\n保留字： 保留字是系统专门保留使用权，并有特定含义的名字，具有唯一性。\n常见的一级目录 链接和库 可执行程序的生成需要经历预处理、编译、汇编、链接4个阶段。\n默认情况下，链接器只搜索默认lib目录(/lib和/usr/lib)中的C标准库libc.a或者libc.so；其余的库(如数学库libm.a或libm.so)则需要指定库的名字甚至库的路径信息才能被链接器搜索到。\n链接的时机： 编译时，即源代码被翻译成机器代码时 (ld) 加载时，即在程序被加载器加载到存储器并准备执行时(ld-linux.so) 运行时，即程序正在运行时(libdl.so.2)\n","date":"2023-02-18T00:00:00Z","image":"https://sryasuka.fun/p/linuxgplunix%E4%BB%8B%E7%BB%8D/Linux_ch01_hua27b2c25dc2bad5a4da2101f5d236246_119733_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/linuxgplunix%E4%BB%8B%E7%BB%8D/","title":"Linux，GPL，UNIX介绍"},{"content":"栈和队列 目标：\r1. 掌握栈和队列的特点，并能在相应的应用问题中正确选用\r2. 熟练掌握栈的两种存储结构的基本操作实现算法，特别应注意栈满和栈空的条件\r3. 熟练掌握循环队列和链队列的基本操作实现算法，特别注意队满和队空的条件\r4. 理解递归算法执行过程中栈的状态变化过程\r5. 掌握表达式求值 方法\r栈的定义 定义：只能在表的一端（栈顶）进行插入和删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见\n运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则\n实现方法：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同。基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等\n队列的定义 定义：只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序队列或链队存储均可\n运算规则：先进先出（FIFO）\n实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同\n*栈，队列和一般线性表的区别 栈、队列是一种特殊（操作受限）的线性表\n区别：仅在于运算规则不同\n一般线性表：\n逻辑结构：一对一 存储结构：顺序表、链表 运算规则：随机、顺序存取 栈\n逻辑结构：一对一 存储结构：顺序栈、链栈 运算规则：后进先出 队列\n逻辑结构：一对一 存储结构：顺序队、链队 运算规则：先进先出 栈的表示和操作的实现 进栈 = 压入 = PUSH()\n出栈 = 弹出 = POP()\n顺序栈与顺序表的区别\n顺序栈的表示 1 2 3 4 5 6 #define MAXSIZE 100 typedef struct{ SElemType *base; SElemType *top; int stacksize; }SqStack; 顺序栈初始化 1 2 3 4 5 6 7 8 9 Status InitStack( SqStack \u0026amp;S ) { S.base =new SElemType[MAXSIZE]； if( !S.base ) return OVERFLOW; S.top = S.base; S.stackSize = MAXSIZE; return OK; } 判断顺序栈是否为空 1 2 3 4 5 6 7 bool StackEmpty( SqStack S ) { if(S.top == S.base) return true; else return false; } 清空顺序栈 1 2 3 4 5 Status ClearStack( SqStack S ) { if( S.base ) S.top = S.base; return OK; } 销毁顺序栈 1 2 3 4 5 6 7 8 9 10 Status DestroyStack( SqStack \u0026amp;S ) { if( S.base ) { delete S.base ; S.stacksize = 0; S.base = S.top = NULL; } return OK; } 顺序栈进栈 1 2 3 4 5 6 7 Status Push( SqStack \u0026amp;S, SElemType e) { if( S.top - S.base== S.stacksize ) // 栈满 return ERROR; *S.top++=e; // *S.top = e; S.top++; return OK; } 顺序栈出栈 1 2 3 4 5 6 7 Status Pop( SqStack \u0026amp;S, SElemType \u0026amp;e) { if( S.top == S.base ) // 栈空 return ERROR; e＝ *--S.top; // --S.top; e = *S.top; return OK; } 链栈的表示 1 2 3 4 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack; 初始化 1 2 3 4 void InitStack(LinkStack \u0026amp;S ) { S=NULL; } 判断链栈是否为空 1 2 3 4 5 Status StackEmpty(LinkStack S) { if (S==NULL) return TRUE; else return FALSE; } 链栈进栈 1 2 3 4 5 6 7 Status Push(LinkStack \u0026amp;S , SElemType e) { p=new StackNode; //生成新结点p if (!p) exit(OVERFLOW); p-\u0026gt;data=e; p-\u0026gt;next=S; S=p; return OK; } 链栈出栈 1 2 3 4 5 6 7 Status Pop (LinkStack \u0026amp;S,SElemType \u0026amp;e) { if (S==NULL) return ERROR; e = S-\u0026gt; data; p = S; S = S-\u0026gt; next; delete p; return OK; } 取链栈栈顶元素 1 2 3 4 5 SElemType GetTop(LinkStack S) { if (S==NULL) exit(1)； else return S–\u0026gt;data; } 栈与递归 递归的定义：若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程\n函数调用过程 时间效率：与递归树的结点数成正比 $$ \\def \\bar#1{#1^n} O(\\bar{2}) $$\n空间效率：与递归树的深度成正比 $$ \\def \\bar#1{n} O(\\bar{}) $$\n递归的优缺点 优点：结构清晰，程序易读\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n队列的表示和操作的实现 1 2 3 4 5 6 #define M 100 //最大队列长度 Typedef struct { QElemType *base; //初始化的动态分配存储空间 int front; //头指针 int rear; //尾指针 }SqQueue; 一维队列：\n存在问题：无法确认是否真溢出\r循环队列：\n循环队列初始化 1 2 3 4 5 6 Status InitQueue (SqQueue \u0026amp;Q){ Q.base =new QElemType[MAXQSIZE] if(!Q.base) exit(OVERFLOW); Q.front=Q.rear=0; return OK; } 求循环队列的长度 1 2 3 int QueueLength (SqQueue Q){ return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; } 循环队列入队 1 2 3 4 5 6 Status EnQueue(SqQueue \u0026amp;Q,QElemType e){ if((Q.rear+1)%MAXQSIZE==Q.front) return ERROR; Q.base[Q.rear]=e; Q.rear=(Q.rear+1)%MAXQSIZE; return OK; } 循环队列出队 1 2 3 4 5 6 Status DeQueue (LinkQueue \u0026amp;Q,QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; e=Q.base[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; return OK; } *链队列\n链队列初始化 1 2 3 4 5 6 Status InitQueue (LinkQueue \u0026amp;Q){ Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-\u0026gt;next=NULL; return OK; } 销毁链队列 1 2 3 4 5 6 7 Status DestroyQueue (LinkQueue \u0026amp;Q){ while(Q.front){ Q.rear=Q.front-\u0026gt;next; free(Q.front); Q.front=Q.rear; } return OK; } 判断链队列是否为空 1 2 3 Status QueueEmpty (LinkQueue Q){ return (Q.front==Q.rear); } 求链队列的队头元素 1 2 3 4 5 Status GetHead (LinkQueue Q, QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; e=Q.front-\u0026gt;next-\u0026gt;data; return OK; } 链队列入队 1 2 3 4 5 6 7 8 Status EnQueue(LinkQueue \u0026amp;Q,QElemType e){ p=(QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-\u0026gt;data=e; p-\u0026gt;next=NULL; Q.rear-\u0026gt;next=p; Q.rear=p; return OK; } 链队列出队 1 2 3 4 5 6 7 8 9 Status DeQueue (LinkQueue \u0026amp;Q,QElemType \u0026amp;e){ if(Q.front==Q.rear) return ERROR; p=Q.front-\u0026gt;next; e=p-\u0026gt;data; Q.front-\u0026gt;next=p-\u0026gt;next; if(Q.rear==p) Q.rear=Q.front; delete p; return OK; } ","date":"2023-02-14T00:00:00Z","image":"https://sryasuka.fun/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/Stacks_and_queues_huda7fe0680db057bb15a758c1801f5cde_24118_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列"},{"content":"线性表 目标： 1. 线性结构特点\r2. 顺序表的定义，创建，插入，删除\r3. 链表的定义，创建，插入，删除\r4. 场景分析\r特点 用数据元素的有限序列表示 同一线性表中的元素必定具有相同的特性\n顺序表 顺序表又称 顺序存储结构/顺序映像\n定义: 逻辑上相邻，物理上也相邻\n存储方法: 用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现。\n顺序表的类型定义 示例：\n顺序表的基本算法操作 初始化 1 2 3 4 5 6 Status InitList_Sq(SqList \u0026amp;L){ //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0;\t//空表长度为0 return OK; } //参数使用引用 1 2 3 4 5 6 Status InitList_Sq(SqList *L){ //构造一个空的顺序表L L-\u0026gt; elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(! L-\u0026gt; elem) exit(OVERFLOW); //存储分配失败 L-\u0026gt; length=0;\t//空表长度为0 return OK; } //参数使用指针 取值（根据位置i获取对应位置的数据元素） 1 2 3 4 5 6 7 int GetElem(SqList L,int i,ElemType \u0026amp;e) { if (i\u0026lt;1||i\u0026gt;L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e=L.elem[i-1]; //第i-1的单元存储着第i个数据 return OK; } 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 int LocateELem(SqList L,ElemType e) { for (i=0;i\u0026lt; L.length;i++) if (L.elem[i]==e) return i+1; return 0; } 插入（插在第 i 个结点之前） （1）判断插入位置i 是否合法。\n（2）判断顺序表的存储空间是否已满。\n（3）将第n至第i 位的元素依次向后移动一个位置，空出第i个位置。\n（4）将要插入的新元素e放入第i个位置。\n（5）表长加1，插入成功返回OK。\n1 2 3 4 5 6 7 8 9 Status ListInsert_Sq(SqList \u0026amp;L,int i ,ElemType e){ if(i\u0026lt;1 || i\u0026gt;L.length+1) return ERROR;\t//i值不合法 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(j=L.length-1;j\u0026gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length;\t//表长增1 return OK; } 删除（删除第i个节点） （1）判断删除位置i 是否合法（合法值为1≤i≤n）。\n（2）将欲删除的元素保留在e中。\n（3）将第i+1至第n 位的元素依次向前移动一个位置。\n（4）表长减1，删除成功返回OK。\n1 2 3 4 5 6 7 Status ListDelete_Sq(SqList \u0026amp;L,int i){ if((i\u0026lt;1)||(i\u0026gt;L.length)) return ERROR;\t//i值不合法 for (j=i;j\u0026lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; } 顺序表的特点 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致\n在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等　这种存取方法称为随机存取法\n优点：\n存储密度大（结点本身所占存储量/结点结构所占存储量）\n可以随机存取表中任一元素\n缺点：\n在插入、删除某一元素时，需要移动大量元素\n浪费存储空间\n属于静态存储形式，数据元素的个数不能自由扩充\n顺序表的时间，空间复杂度 查找、插入、删除算法的平均时间复杂度为 O(n)\n顺序表的空间复杂度S(n)=O(1) （没有占用辅助空间）\n链表 结点在存储器中的位置是任意的即逻辑上相邻的数据元素在物理上不一定相邻\n通过指针进行实现\n各结点由两个域组成：\n数据域：存储元素数值数据\n指针域：存储直接后继结点的存储位置\n链表的分类：单链表，双链表，循环链表\n单链表：结点只有一个指针域。\n双链表：结点有两个指针域的链表\n循环链表：首尾相接的链表\n头指针，头结点和首元结点 链表表头设置头结点的好处：\n方便首元结点处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;\n便于空表和非空表的统一处理 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\nPS：头结点可以为空，也可以存储线性表长度的附加信息，不会被记录长度\n单链表的定义与实现 单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名\n若头指针名是L，则把链表称为表L\nLNode * 与 LinkList 等价\n单链表的基本算法操作 初始化 1 2 3 4 5 Status InitList_L(LinkList \u0026amp;L){ L=new LNode; L-\u0026gt;next=NULL;　return OK; } 销毁 1 2 3 4 5 6 7 8 9 10 Status DestroyList_L(LinkList \u0026amp;L){ LinkList p; while(L) { p=L; L=L-\u0026gt;next; delete p; } return OK; } 清空 1 2 3 4 5 6 7 8 9 Status ClearList(LinkList \u0026amp; L){ // 将L重置为空表 LinkList p,q; p=L-\u0026gt;next; //p指向第一个结点 while(p) //没到表尾 { q=p-\u0026gt;next; delete p; p=q; } L-\u0026gt;next=NULL; //头结点指针域为空 return OK; } 求表长 1 2 3 4 5 6 7 8 9 10 int ListLength_L(LinkList L){ //返回L中数据元素个数 LinkList p; p=L-\u0026gt;next; //p指向第一个结点 i=0; while(p){//遍历单链表,统计结点数 i++; p=p-\u0026gt;next; } return i; } 判断表是否为空 1 2 3 4 5 6 7 int ListEmpty(LinkList L){ //若L为空表，则返回1，否则返回0 if(L-\u0026gt;next) //非空 return 0; else return 1; } 取值（根据位置i获取相应位置数据元素的内容） 1 2 3 4 5 6 7 8 9 Status GetElem_L(LinkList L,int i,ElemType \u0026amp;e){ p=L-\u0026gt;next;j=1; //初始化 while(p\u0026amp;\u0026amp;j\u0026lt;i){\t//向后扫描，直到p指向第i个元素或p为空 p=p-\u0026gt;next; ++j; } if(!p || j\u0026gt;i)return ERROR; //第i个元素不存在 e=p-\u0026gt;data; //取第i个元素 return OK; }//GetElem_L 查找（根据指定数据获取数据所在的位置） 1 2 3 4 5 6 LNode *LocateELem_L (LinkList L，Elemtype e) { //返回L中值为e的数据元素的地址，查找失败返回NULL p=L-\u0026gt;next; while(p \u0026amp;\u0026amp;p-\u0026gt;data!=e) p=p-\u0026gt;next; return p; } 插入（插在第 i 个结点之前） 1 2 3 4 5 6 7 8 9 10 Status ListInsert_L(LinkList \u0026amp;L,int i,ElemType e){ p=L;j=0; while(p\u0026amp;\u0026amp;j\u0026lt;i−1){p=p-\u0026gt;next;++j;}\t//寻找第i−1个结点 if(!p||j\u0026gt;i−1)return ERROR;\t//i大于表长 + 1或者小于1 s=new LNode;\t//生成新结点s s-\u0026gt;data=e; //将结点s的数据域置为e s-\u0026gt;next=p-\u0026gt;next;\t//将结点s插入L中 p-\u0026gt;next=s; return OK; }//ListInsert_L 删除（删除第 i 个结点） 1 2 3 4 5 6 7 8 9 10 11 12 Status ListDelete_L(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ p=L;j=0; while(p-\u0026gt;next \u0026amp;\u0026amp;j\u0026lt;i-1){//寻找第i个结点，并令p指向其前驱 p=p-\u0026gt;next; ++j; } if(!(p-\u0026gt;next)||j\u0026gt;i-1) return ERROR; //删除位置不合理 q=p-\u0026gt;next; //临时保存被删结点的地址以备释放 p-\u0026gt;next=q-\u0026gt;next; //改变删除结点前驱结点的指针域 e=q-\u0026gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; }//ListDelete_L 链表的特点 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等\n这种存取元素的方法被称为顺序存取法\n优点:\n数据元素的个数可以自由扩充\n插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高\n缺点：\n存储密度小\n存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）\n链表的时间，空间复杂度 查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。\n插入和删除: 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为 O(1)。\n如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n) 。\n*单链表的建立 方法一：前插法\n1 2 3 4 5 6 7 8 9 10 void CreateList_F(LinkList \u0026amp;L,int n){ L=new LNode; L-\u0026gt;next=NULL; //先建立一个带头结点的单链表 for(i=n;i\u0026gt;0;--i){ p=new LNode; //生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; //插入到表头 } }//CreateList_F 方法二：后插法\n1 2 3 4 5 6 7 8 9 10 11 12 void CreateList_L(LinkList \u0026amp;L,int n){ //正位序输入n个元素的值，建立带表头结点的单链表L L=new LNode; L-\u0026gt;next=NULL; r=L; //尾指针r指向头结点 for(i=0;i\u0026lt;n;++i){ p=new LNode;\t//生成新结点 cin\u0026gt;\u0026gt;p-\u0026gt;data; //输入元素值 p-\u0026gt;next=NULL; r-\u0026gt;next=p; //插入到表尾 r=p; //r指向新的尾结点 } }//CreateList_L *双向链表和循环链表的共性特点 循环链表和双向链表是两种常见的链式存储结构，它们的共性如下：\n都是链式存储：链式存储是指线性数据结构的一种存储方式，在这种方式中，数据不是顺次存储在内存单元中，而是通过一个指针将相邻的数据连接在一起。\n都可以实现动态的数据存储：链式存储的线性结构可以随着数据的添加和删除动态变化，避免因为数据量固定导致的内存浪费。\n都是非连续存储：链式存储的数据不是顺次存储在内存单元中，而是分散存储在各个不同的内存单元中，因此是非连续的。\n循环链表的特点：\n循环：循环链表是一种特殊的链式存储结构，其特殊之处在于，最后一个数据元素的指针指向链表的第一个元素，实现了循环结构。\n方便遍历：由于循环链表结构中的数据元素是相互连接的，因此，可以方便地从一个数据元素遍历到另一个数据元素。\n双向链表的特点：\n双向链接双向链表是一种特殊的链式存储结构，每个数据元素同时包含了前驱和后继的指针，使得可以从前面和后面同时遍历链表。\n方便插入和删除：由于双向链表中每个数据元素都包含了前驱和后继的指针，因此，可以方便地在链表的任意位置插入和删除数据元素。\n顺序表和链表的比较 ","date":"2023-02-12T00:00:00Z","image":"https://sryasuka.fun/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/Linear_tables_hua6ee4ed3cf660c859c134ad90be5e6ce_35023_120x120_fill_box_smart1_3.png","permalink":"https://sryasuka.fun/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"线性表"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://sryasuka.fun/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://sryasuka.fun/p/test-chinese/","title":"Chinese Test"}]